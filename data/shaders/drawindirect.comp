#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shader_atomic_counters : enable

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(std140, set = 0, binding = 0) buffer Positions
{
  vec4 positions[];
};

layout(set = 0, binding = 1) uniform ComputeScale {
    vec4 scale;
};

struct DrawIndirectCommand
{
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
};

layout(std140, set = 0, binding = 2) buffer DrawBuffer
{
	DrawIndirectCommand draws[];
} drawBuffer;

layout (local_size_x = 4) in;
layout (local_size_y = 4) in;


struct Frustum
{
    vec4 left;
    vec4 right;
    vec4 top;
    vec4 bottom;
    vec4 near;
    vec4 far;
};

Frustum computeFrustum()
{
    mat4 pvm = pc.projection * pc.modelView;

    Frustum f;
    f.left = vec4(pvm[0][0] + pvm[0][3], pvm[1][0] + pvm[1][3], pvm[2][0] + pvm[2][3], pvm[3][0] + pvm[3][3]);
    f.left = f.left / length(f.left.xyz);

    f.right = vec4(-pvm[0][0] + pvm[0][3], -pvm[1][0] + pvm[1][3], -pvm[2][0] + pvm[2][3], -pvm[3][0] + pvm[3][3]);
    f.right = f.right / length(f.right.xyz);

    f.top = vec4(pvm[0][1] + pvm[0][3], pvm[1][1] + pvm[1][3], pvm[2][1] + pvm[2][3], pvm[3][1] + pvm[3][3]);
    f.top = f.top / length(f.top.xyz);

    f.bottom = vec4(-pvm[0][1] + pvm[0][3], -pvm[1][1] + pvm[1][3], -pvm[2][1] + pvm[2][3], -pvm[3][1] + pvm[3][3]);
    f.bottom = f.bottom / length(f.bottom.xyz);

    // near plane is depth 1.0 due to reverse depth projection matrix
    f.near = vec4(pvm[0][2] + pvm[0][3], pvm[1][2] + pvm[1][3], pvm[2][2] + pvm[2][3], pvm[3][2] + pvm[3][3]);
    f.near = f.near / length(f.near.xyz);

    // far plane is depth 0.0 due to reverse depth projection matrix
    f.far = vec4(pvm[0][2], pvm[1][2], pvm[2][2], pvm[3][2]);
    f.far = f.far / length(f.far.xyz);
    return f;
}

void main()
{
  uint i = gl_GlobalInvocationID.x;
  uint j = gl_GlobalInvocationID.y;
  float x = float(i) / 15 - 0.5;
  float y = float(j) / 15 - 0.5;
  float z = (0.25 * sin(2.0 * 3.14 * x) + 0.25 * cos(2.0 * 3.14 * y));

  vec4 vertex = vec4(x, y, z, 1) * scale;

  Frustum f = computeFrustum();

  float distance = dot(f.near, vertex);
  if (distance < 5.0)
  {
    positions[atomicAdd(drawBuffer.draws[0].vertexCount, 1)] = vertex;
  }
}
